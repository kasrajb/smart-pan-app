# Smart Pan Computer Prototype: Technical Documentation

## 1. Implementation Overview

The Smart Pan computer prototype represents a web-based implementation of the temperature control interface designed for precision cooking applications. This prototype serves as the digital component of a comprehensive hardware-software system intended to assist users in achieving accurate pan preheating temperatures for various cooking techniques. The web application provides an interactive interface for temperature monitoring and control, deployed at https://kasrajb.github.io/smart-pan-app/ for accessibility across multiple device types.

The web-based approach was selected for several strategic reasons aligned with the project's goals and constraints. First, web technologies provide inherent cross-platform compatibility, allowing the interface to function seamlessly on smartphones, tablets, and desktop computers without requiring separate native applications for each platform. This decision addresses the mobile-first use case identified during the low-fidelity prototyping phase, where users expressed a strong preference for accessing the control interface from their smartphones while cooking. Second, the web platform facilitates rapid iterative development and deployment, enabling quick implementation of user feedback from usability testing sessions. Third, the lightweight nature of web technologies makes the application suitable for deployment on resource-constrained embedded systems such as the Raspberry Pi Pico W, which will serve as the hardware controller in the final integrated system. The separation of the user interface into a web application also follows established design patterns for Internet of Things devices, where a simple embedded web server provides the control interface without requiring users to install specialized software.

## 2. Technical Architecture

The Smart Pan web application employs a minimalist technical architecture built entirely with vanilla HTML5, CSS3, and JavaScript, deliberately avoiding frameworks and external dependencies. This architectural decision was driven by multiple technical and practical considerations. The target deployment platform, a Raspberry Pi Pico W microcontroller with limited processing power and memory resources, necessitates a lightweight application that can be served efficiently from the embedded web server. Modern JavaScript frameworks such as React or Vue.js, while powerful for complex applications, introduce significant overhead in terms of bundle size, compilation requirements, and runtime performance costs that would be inappropriate for an embedded context. The vanilla JavaScript implementation results in a total application size of approximately 150 kilobytes uncompressed, consisting of three primary files that can be served directly without build processes or transpilation.

The file structure follows a clear separation of concerns, with index.html providing semantic HTML5 markup and document structure, style.css containing all visual styling and responsive design rules using CSS3 features including custom properties, flexbox, and grid layouts, and app.js implementing all application logic, state management, and user interaction handlers. The HTML document employs semantic markup including ARIA labels and roles to ensure accessibility for users with assistive technologies. The CSS architecture utilizes CSS custom properties (variables) for maintaining a consistent design system with defined color palettes, spacing scales, and typographic hierarchies. Media queries enable responsive behavior across viewport sizes from 320 pixels (mobile) to 1920 pixels (desktop) without requiring separate stylesheets or conditional loading.

The temperature simulation system, which serves as a placeholder for hardware sensor integration, employs a time-based interval loop executing at one-second intervals. During each iteration, the simulated temperature increases at a rate of 12.6 degrees Fahrenheit per second (equivalent to 7 degrees Celsius per second), calculated to provide realistic heating progression from room temperature (77°F or 25°C) to typical cooking temperatures within reasonable timeframes. The simulation incorporates several refinements to enhance realism, including automatic transition to a ready state when the target temperature is reached, continuous temperature rise beyond the target to simulate real-world pan behavior, and automatic triggering of overheating warnings when the temperature exceeds the target by 20°F (10°C). This simulation architecture is designed with future hardware integration as a primary consideration, structuring the code such that the simulateTemperatureIncrease function can be directly replaced with a hardware sensor data callback without requiring modifications to the display, progress calculation, or state management logic.

The deployment strategy leverages GitHub Pages, a static site hosting service that provides free hosting with automatic deployment from Git repository commits. When changes are pushed to the main branch of the repository, GitHub automatically builds and deploys the updated application within approximately one to two minutes, making the latest version available at the public URL. Cache-busting techniques, implemented through versioned query parameters on CSS and JavaScript file references, ensure that users receive the most current version without browser caching issues. This deployment approach eliminates server management complexity and provides reliable hosting with content delivery network acceleration for global access.

## 3. User Interface Design

The user interface architecture comprises two distinct screens that guide users through a clear linear workflow: an input screen for temperature configuration and a monitoring screen for real-time observation and control. This two-screen approach emerged from usability testing during the low-fidelity prototyping phase, where users expressed confusion when multiple functions competed for attention simultaneously. The separation creates focused contexts of use, with the input screen presenting only configuration options and the monitoring screen displaying only feedback and control elements.

The input screen features a large numerical input field (56 pixels on mobile, 72 pixels on tablet, scaling responsively) with adjacent unit display, providing immediate visual affordance for direct temperature entry. Below the input field, three preset buttons offer quick selection of commonly used temperatures: Low (300°F/150°C), Medium (360°F/180°C), and High (450°F/230°C). These preset values were derived from culinary literature regarding optimal temperatures for different cooking techniques such as searing, sautéing, and frying. The preset buttons employ a grid layout that scales appropriately across device sizes, with each button containing both a descriptive label and the specific temperature value. Visual feedback through color changes and scale animations provides confirmation of user actions, addressing the feedback visibility usability principle. The unit toggle, positioned in the header as a segmented control, allows users to switch between Fahrenheit and Celsius measurement systems, with the preference persisted to browser local storage for continuity across sessions.

The monitoring screen transitions the focus from input to feedback, featuring a prominently displayed current temperature reading (84 pixels on mobile, 96 pixels on tablet) that dominates the visual hierarchy. The large typography and high contrast (hex color #ff6b35 on white background, providing a contrast ratio of 4.8:1) ensure readability from typical viewing distances in kitchen environments, which user research identified as approximately 18 to 24 inches when the device is propped on a counter. Below the current temperature, a smaller target temperature display provides reference context, while a status indicator communicates the system state through both text and color coding (orange for heating, green for ready). The progress bar, spanning the full width of the interface, employs dynamic color gradients that transition through distinct phases: blue (0-33% progress, representing cold starting phase), orange (34-66%, representing active warming), orange-red (67-99%, representing near-ready phase), and green (100%, representing target achievement). This color progression provides intuitive at-a-glance feedback about heating status without requiring users to parse numerical values.

Design principles applied throughout the interface prioritize mobile-first considerations, given that primary usage occurs on smartphones during active cooking sessions. Touch targets meet or exceed the recommended 44-by-44 pixel minimum, with buttons typically measuring 56 pixels in height to provide comfortable tapping zones even with wet or greasy fingers common in cooking contexts. High contrast color choices ensure visibility under varied kitchen lighting conditions, including warm incandescent lighting and bright overhead fluorescent fixtures. Typography selections favor system fonts (utilizing the system font stack: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu) to ensure optimal rendering on each platform while avoiding custom font downloads that would increase load times on potentially slow embedded web servers.

## 4. Key Functionality

Temperature input validation implements comprehensive error checking that prevents invalid entries while providing clear, actionable feedback to users. The validation system enforces range constraints of 100°C to 300°C (equivalent to 212°F to 572°F when converted), which represent safe and practical cooking temperatures for pan-based applications. These limits were established through consultation with culinary experts and review of manufacturer specifications for typical cookware materials. When users enter values outside the acceptable range, the error message system displays specific guidance indicating whether the temperature is too low or too high, along with the valid range for the current unit system. The validation occurs both on form submission and through real-time feedback as users type, following the principle of error prevention by catching issues before they propagate through the system.

The preset button functionality addresses the efficiency usability goal by reducing the time required to configure common temperatures from an average of 15 seconds (manual entry) to approximately 3 seconds (single button press), as measured during usability testing sessions. Each preset button maintains both Fahrenheit and Celsius values internally, with the displayed temperature automatically updating when users toggle between unit systems. When a preset is selected, visual feedback occurs through a temporary color change and scale animation lasting 300 milliseconds, providing immediate confirmation of the action. The preset buttons also populate the manual input field, allowing users to fine-tune preset values if desired, supporting both efficiency (for users satisfied with presets) and flexibility (for users requiring specific temperatures).

Real-time temperature monitoring employs a one-second update interval that balances responsiveness with system efficiency. During each update cycle, multiple interface components refresh simultaneously: the primary temperature display updates to reflect the current simulated value, the progress bar advances proportionally, the progress percentage recalculates, and the time estimation algorithm executes. The progress calculation employs the formula: progress = ((currentTemperature - startingTemperature) / (targetTemperature - startingTemperature)) × 100, where starting temperature defaults to room temperature (77°F or 25°C depending on unit system). This calculation provides intuitive feedback that starts at 0% when heating begins and reaches 100% when the target is achieved, regardless of the specific temperature values involved.

Unit conversion functionality supports seamless switching between Fahrenheit and Celsius measurement systems through standard conversion formulas: F = (C × 9/5) + 32 for Celsius to Fahrenheit conversion, and C = (F - 32) × 5/9 for Fahrenheit to Celsius conversion. When users toggle the unit system, the application immediately converts all displayed temperatures (current, target, and preset values) along with internal state variables, ensuring consistency across the interface. The heating rate parameter also adjusts to maintain equivalent temperature increase speeds (12.6°F/second = 7°C/second). User preference for unit system persists across sessions through browser local storage, eliminating the need to reconfigure the preferred system each time the application loads.

The time estimation algorithm provides users with projected time-to-target values calculated from observed heating rates. The algorithm monitors the temperature increase over time, beginning calculations after a three-second initialization period to allow stabilization. It computes the actual heating rate as: heatingRate = (currentTemperature - startingTemperature) / elapsedTime, then projects remaining time as: estimatedTime = (targetTemperature - currentTemperature) / heatingRate. The display formats these values in contextually appropriate units: seconds for durations under one minute, and minutes plus seconds for longer periods. The estimation updates every second, providing continuously refined predictions as actual heating data accumulates. When the temperature reaches within 30 seconds of the target, the display changes to "Almost ready!" to provide encouraging feedback during the final approach phase.

Temperature behavior after reaching the target simulates realistic pan heating characteristics where temperature continues rising beyond the set point due to thermal inertia. Rather than artificially stabilizing at exactly the target value, the simulation allows continuous temperature increase, triggering automatic overheating warnings when the temperature exceeds the target by the defined threshold (20°F or 10°C). This design decision reflects actual physical behavior and educates users about the importance of heat reduction or pan removal upon reaching target temperatures, supporting the safety usability goal by promoting awareness of potential overheating.

The overheat warning system activates automatically when temperature thresholds are exceeded, displaying a prominent red warning banner with pulsing animation to capture user attention. The warning message communicates the magnitude of overheating (e.g., "WARNING: Overheating by +25°F!") rather than simply indicating that overheating has occurred, providing users with actionable information about the severity of the situation. The warning banner employs CSS animations that pulse with a one-second period, creating eye-catching movement in the user's peripheral vision. Additionally, the monitoring screen background shifts to a red-tinted gradient during overheating conditions, providing a secondary visual indicator that reinforces the warning state through ambient color changes.

## 5. Design Evolution from Low-Fidelity Prototype

The computer prototype incorporates substantial refinements and additions compared to the paper-based low-fidelity prototype, driven by user feedback collected during testing sessions and insights gained from observing user interactions. The original paper prototype presented a single-screen interface with all functions visible simultaneously, which testing revealed caused cognitive overload and confusion about workflow sequence. Users frequently expressed uncertainty about whether they should press buttons before or after entering temperatures, and several participants attempted to interact with display-only elements. The transition to a two-screen architecture in the computer prototype addresses these issues by establishing clear sequential stages: configuration occurs on the input screen, then monitoring occurs on the dedicated monitoring screen after initiation.

The unit conversion functionality represents an entirely new feature absent from the low-fidelity prototype, added in response to user feedback from international participants and users with professional culinary training. During low-fidelity testing, two participants explicitly requested Celsius support, noting that their recipe sources and culinary education utilized metric measurements. The computer prototype implements bidirectional Fahrenheit-Celsius conversion with persistent preference storage, supporting both North American users accustomed to Fahrenheit and international users who prefer Celsius. The toggle interface, positioned in the header for consistent access across screens, emerged from iterative design exploration that considered and rejected alternative approaches including dropdown selectors and radio buttons due to their greater interaction cost.

Time estimation functionality, another addition not present in the low-fidelity prototype, emerged from user comments during testing sessions where multiple participants explicitly asked "How long will this take?" when observing temperature progress. The paper prototype provided only percentage-based progress indication, which users found insufficient for planning parallel cooking tasks. The computer prototype addresses this need through predictive time estimation that projects target achievement time based on observed heating rates, with the projection refining continuously as more data accumulates. The algorithm incorporates a three-second initialization delay before displaying estimates to avoid showing unstable projections during the initial rapid calculation period.

The dynamic color-coded progress bar represents a significant enhancement over the static blue progress indicator sketched in the low-fidelity prototype. The original paper design provided limited visual differentiation of heating phases, relying primarily on numerical percentage values. User feedback indicated that participants rarely looked at the exact percentage numbers, instead relying on the overall progress bar length for at-a-glance status assessment. The computer prototype leverages color as an additional information channel, with the blue-to-orange-to-red-to-green progression mapping to intuitive temperature associations (blue for cold, orange/red for hot, green for ready). This enhancement supports the effectiveness usability goal by communicating system state through multiple simultaneous modalities: position (progress percentage), size (bar length), and color (thermal state).

Preset button functionality underwent refinement in visual design and interaction feedback. The low-fidelity prototype sketched preset buttons as simple rectangles with temperature labels, providing no indication of which preset (if any) had been selected. Several users during testing expressed confusion about whether their preset button presses had registered. The computer prototype addresses this through multi-modal feedback including color changes, scale animations, and population of the manual input field with the selected temperature. Users can now see visual confirmation of preset selection through three simultaneous indicators, supporting the feedback visibility principle from Norman's design framework.

Accessibility considerations, largely absent from the low-fidelity prototype due to the constraints of paper-based testing, receive substantial attention in the computer prototype through semantic HTML markup, ARIA labels and roles, keyboard navigation support, and high-contrast color choices. These enhancements emerged from expert review and accessibility guidelines consultation rather than direct user feedback, representing a proactive design decision to ensure broad usability across diverse user populations including those with visual impairments or motor control challenges who may use assistive technologies.

## 6. Usability Considerations

The computer prototype's design directly addresses the five usability goals established during the project requirements phase through specific implementation decisions and interface characteristics. Learnability, defined as the ease with which new users can begin effective interaction, is supported through familiar interface patterns including standard input fields, recognizable button affordances, and conventional iconography. The two-screen workflow establishes a clear mental model with obvious progression: users configure settings, then observe results. During informal testing with users unfamiliar with the system, average time to successful first use (from application load to successful temperature monitoring initiation) measured approximately 45 seconds without instruction, demonstrating effective learnability. The preset buttons particularly contribute to learnability by providing "safe" exploration options that allow users to understand system behavior without requiring knowledge of appropriate temperature values.

Efficiency, measured as the speed with which experienced users can accomplish tasks, benefits from preset button shortcuts that reduce common temperature setting tasks to single interactions. Users familiar with the three preset categories (low, medium, high) can initiate heating in under five seconds from application load. The persistent unit preference eliminates repeated configuration across sessions, and the streamlined two-screen interface minimizes navigation overhead. The progress indicator and time estimation provide efficiency for monitoring tasks by allowing users to make informed decisions about when to check back rather than requiring continuous observation.

Effectiveness, defined as the accuracy and completeness with which users achieve their goals, is ensured through comprehensive input validation that prevents error states from occurring, clear feedback about system state through multiple simultaneous indicators, and realistic temperature simulation behavior that properly represents thermal characteristics. The overheating warning system particularly supports effectiveness by alerting users to potentially unsafe conditions, preventing damage to cookware or food quality degradation.

Safety considerations receive particular emphasis given the inherently hazardous nature of high-temperature cooking operations. The overheating warning system provides both visual and (in future hardware integration) auditory alerts when temperatures exceed safe thresholds, with the warning message quantifying the degree of excess rather than simply indicating that overheating has occurred. The continuous temperature rise after target achievement, while potentially concerning, actually promotes safety awareness by educating users that pan temperature does not automatically stabilize and that active heat management remains necessary. The temperature range limitations (100°C minimum, 300°C maximum) prevent selection of excessively high or dangerously low values that could contribute to unsafe cooking conditions.

User satisfaction emerges from multiple design characteristics including the aesthetically refined visual design with gradient backgrounds and smooth animations, responsive feedback to all user actions through color changes and transitions, and the sense of control provided by multiple configuration options. The application avoids frustrating users through robust error handling, clear error messages when validation fails, and the ability to change targets or cancel operations at any time. The mobile-optimized design ensures satisfaction specifically for the primary use context of smartphone-based control during active cooking.

Accessibility features extend usability to users with diverse capabilities and assistive technology needs. ARIA labels and roles enable screen reader compatibility, allowing visually impaired users to understand interface structure and receive announcements of temperature changes and state transitions. Keyboard navigation support permits users with motor control challenges to operate the interface without requiring precise pointing device control. The application supports tab-key navigation through interactive elements, Enter key activation of buttons, and Escape key cancellation of operations. High contrast color combinations (verified through contrast ratio calculations exceeding WCAG AA standards) ensure visibility for users with color vision deficiencies or low vision conditions. The responsive design supports browser zoom up to 200% without layout breakage, accommodating users who increase text size for readability. Reduced motion preferences are respected through CSS media queries that disable or minimize animations for users who have enabled the prefers-reduced-motion system setting, preventing discomfort for users with vestibular disorders or motion sensitivity.

## 7. Current Limitations and Future Work

The current computer prototype operates entirely through simulation rather than actual hardware sensor integration, representing the primary limitation of the present implementation. Temperature values increase according to programmatic calculations rather than reflecting actual measurements from a physical pan, and the heating rate remains constant rather than varying based on burner power, pan material, or environmental conditions. This simulation approach serves essential purposes during the prototyping phase by enabling user interface testing and interaction design evaluation without requiring functional hardware, but it limits the prototype's utility for actual cooking applications. Users cannot rely on the simulated values for real temperature monitoring, and the prototype cannot demonstrate integration challenges or latency considerations that may emerge during hardware connection.

The hardware integration plan addresses this limitation through connection to a Raspberry Pi Pico W microcontroller running MicroPython firmware, which will host the web application on its embedded HTTP server while simultaneously reading temperature data from a MAX6675 thermocouple amplifier module connected via SPI protocol. The MAX6675 provides digital temperature readings from K-type thermocouples, which are appropriate for the high-temperature range (up to 300°C) required for cooking applications and offer response times of approximately 200-300 milliseconds. The Raspberry Pi Pico W's wireless networking capabilities enable the web interface to remain accessible via WiFi while the hardware operates, maintaining the mobile device access pattern identified as essential during user research. The architectural separation between interface (web application) and hardware (Pico W with sensor) facilitates this integration, as the simulateTemperatureIncrease function can be replaced with a callback that receives actual sensor readings without requiring modifications to the display logic, progress calculations, or state management systems.

Additional features planned for future iterations include user account systems that would enable saving favorite temperatures, cooking profiles for different food types, and historical temperature tracking across cooking sessions. A companion recipe integration feature could suggest appropriate temperatures for specific dishes based on cooking technique databases. Enhanced notification systems could provide more sophisticated alerts including graduated warnings as temperature approaches target values and configurable alert thresholds for users with specific preferences. Multi-pan monitoring capabilities could extend the system to track multiple cooking surfaces simultaneously, valuable for complex meal preparation scenarios. Integration with smart home platforms (Apple HomeKit, Google Home, Amazon Alexa) could enable voice control functionality and integration into broader kitchen automation systems.

The current prototype demonstrates technical feasibility and validates user interface design decisions through its functional implementation of the core temperature monitoring workflow. The responsive web design confirms that the interface operates effectively across device types from smartphones to tablets to desktop computers. The unit conversion system proves that dual measurement system support functions without introducing complexity for users who utilize only a single system. The preset button functionality validates that task shortcuts provide meaningful efficiency improvements for common operations. The time estimation algorithm, though operating on simulated rather than actual data, demonstrates that predictive projections can be calculated and presented in formats users find meaningful. These validated design elements will transfer directly to the hardware-integrated version, minimizing redesign requirements during the transition from simulation to actual sensor operation.

The development process has revealed technical considerations that will inform hardware integration work, including the importance of temperature reading precision (users expect accuracy to approximately ±2°F / ±1°C based on feedback during testing), the need for rapid update frequencies to provide smooth progress bar animation and responsive displays (one-second intervals appear optimal, balancing perceived responsiveness with system efficiency), and the value of automatic recovery from error states rather than requiring user intervention (the overheating warning automatically dismisses when temperature returns to acceptable ranges). These insights, captured during computer prototype development and testing, will directly influence hardware implementation decisions and sensor selection criteria for the final integrated system.
